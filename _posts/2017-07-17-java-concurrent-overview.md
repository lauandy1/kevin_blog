---
layout: post
title: Java多线程
author: andy
tags:  java concurrent
categories:  java concurrent
excerpt: 线程安全
---

* TOC
{:toc}

## 线程安全
按照线程安全的安全程度由强至弱来排序。

    1.不可变类
    String、Integer、Double、Long、BigDecimal
	2.绝对线程安全
	3.相对线程安全
	大部分线程安全类都属于这种，Vector、HashTable、Collections的synchronizedCollection()
	方法包装的集合。
	4.线程兼容
	指对象本身并不是线程安全，但是使用同步手段可以达到在并发环境中安全使用。比如ArrayList和HashMap。
	5.线程对立

## 线程安全的实现
### 互斥同步。
临界区、互斥量、信号量都是主要的互斥实现方式。

    * Synchronized关键字。
    * 重入锁ReentrantLock。
    基本用法上很相似，只是代码写法上有点区别，一个是API层面的互斥锁lock()和unlock()方法配合try/finally语句块来完成，
    另一个表现为原生语法层面的互斥锁。不过ReentrantLock增加了一些高级功能。
    等待可中断、可实现公平锁、以及锁可以绑定多个条件。
    1.等待可中断是指持有锁的线程长时间不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。
    2.公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁，而非公平锁不保证这一点。Synchronized中的锁
    是非公平锁，ReentrantLock默认也是非公平锁。
    3.锁绑定条件是指ReentrantLock对象可以同时绑定多个Condition对象，而在Synchronized中，锁对象的wait和notify方法可以
    实现一个隐含的条件，如果要和多于一个条件关联就不得不额外添加一个锁，而ReentrantLock只需多次调用newCondition()方法即可。

### 非阻塞同步。

    * 互斥同步属于悲观的并发策略。无论共享数据是否真的会出现竞争，他都要进行加锁、用户核心态转换、维护锁计数器和检查
    是否有被阻塞的线程需要唤醒等操作。	
    * 随着硬件指令集发展，我们有了另外一个选择：基于冲突检测的乐观并发策略。先操作，可能成功，也可能产生冲突，如果产生
    冲突就采取其他的补偿措施，比如重试直到成功。这种乐观并发策略不需要挂起线程，属于非阻塞同步。
    * 硬件保证从一个语义上看起来需要多次操作的行为只通过一条处理器指令就能完成。这类指令常用的有：
    测试并设置（Test-and-Set）
    获取并增加（Fetch-and-Increment）
    交换（Swap）
    比较并交换（Compare-and-Swap，简称CAS）
    * CAS的逻辑漏洞
    没法解决ABA问题，如果初次读取值为A，然后值曾经变成B，最后又被改回了A，CAS操作会认为从未变过。
    不过大部分情况下ABA问题不会影响程序并发的正确性。

### 无同步方案。

    * 有些代码天生就是线程安全的。
    * 可重入代码。不依赖堆和公共的系统资源，用到的状态量都是参数中传入、不调用非可重入方法等。
    * 线程本地存储。可见范围限制在同一个线程内。

## 锁优化
高效并发是从1.5到1.6的一个重要改进。
### 自旋锁与自适应自旋

	如果物理机有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的线程稍等一下，
	但不放弃处理器的执行时间，看看持有锁的线程是否很快释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋）。
	自旋等待时间必须有个限度，如果超过限定的次数仍然没有获得锁，就应该用传统的方式去挂起线程了。jdk1.6加入了自适应自旋。

### 锁消除

	锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。

### 锁粗化
### 轻量级锁
### 偏向锁

---





