---
layout: post
title: 类加载器原理简介
author: andy
tags:  jvm classloader thread
categories:  jvm
excerpt: 类加载器介绍、双亲委派机制、破坏双亲委派机制
---


* TOC
{:toc}

# 前言
简单记录一下类加载机制。

# 概要

## 类加载器类型
> 启动（Bootstrap）类加载器、扩展（Extension）类加载器、系统（System）类加载器

## 双亲委派机制
> 就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。

## 破坏双亲委派机制

### 线程上下文类加载器

> *    Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。
*    这些 SPI 的接口由 Java 核心库来提供，而这些 SPI 的实现代码则是作为 Java 应用所依赖的 jar 包被包含进类路径（CLASSPATH）里。SPI接口中的代码经常需要加载具体的实现类。那么问题来了，SPI的接口是Java核心库的一部分，是由引导类加载器来加载的；SPI的实现类是由系统类加载器来加载的。引导类加载器是无法找到 SPI 的实现类的，因为依照双亲委派模型，BootstrapClassloader无法委派AppClassLoader来加载类。
*    而线程上下文类加载器破坏了“双亲委派模型”，可以在执行线程中抛弃双亲委派加载链模式，使程序可以逆向使用类加载器。

### 热部署、OSGI等技术
> 除了SPI这种场景会破坏双亲委派机制，还有热部署、OSGI等技术也会破坏双亲委派机制。

## 自定义类加载器应用实例
### Tomcat：正统的类加载器架构

> *    部署在同一个服务器上的两个web应用所使用的Java类库可以实现相互隔离，这是最基本的需求，两个不同应用程序可能会依赖同一个第三方库的不同版本，服务器应当保证两个应用程序的类库可以独立使用。
*    同时，不同应用的Java类库可以相互共享，比如都依赖同一套spring类库。

---





